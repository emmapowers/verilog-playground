#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
vproj — Vivado project manager (add/remove/list/export-tcl/import-tcl)

Requires:
  - Python 3.8+
  - click (pip install click)
  - Vivado available in PATH, or pass --settings to source settings64.sh

Examples:
  vproj list
  vproj add src/top.sv constrs/nexys_a7_100t.xdc
  vproj remove src/old.sv
  vproj export-tcl --out project.tcl --rel-to .
  vproj import-tcl project.tcl

  # If Vivado isn't on PATH:
  vproj --settings /opt/Xilinx/Vivado/2024.1/settings64.sh list
"""
from __future__ import annotations

import code
import os
import re
import shlex
import subprocess
import sys
import tempfile
from pathlib import Path
from typing import Iterable, List, Optional, Tuple

import click

PROJECT_DIR_DEFAULT = "project_files"

# --------------------------- file-kind detection ------------------------------

EXT_KIND = {
    # HDL
    ".v": "hdl",
    ".sv": "hdl",
    ".vhd": "hdl",
    ".vhdl": "hdl",
    ".xci": "ip",
    ".bd": "ip",

    # Headers (kept in sources_1 by default)
    ".vh": "header",
    ".svh": "header",

    # Constraints
    ".xdc": "xdc",

    # Other (mem inits, tcl helpers, etc.)
    ".mem": "other",
    ".tcl": "other",
}
KIND_FILESET = {
    "hdl": "sources_1",
    "header": "sources_1",
    "ip": "sources_1",
    "xdc": "constrs_1",
    "sim": "sim_1",
    "other": "sources_1",
}
VALID_KINDS = tuple(sorted(set(KIND_FILESET.keys())))


def detect_kind(path: Path) -> str:
    ext = path.suffix.lower()
    k = EXT_KIND.get(ext)
    if k:
        return k
    # Heuristic: HDL under /sim/ or /tb/ folders → sim fileset
    if ext in {".v", ".sv", ".vhd", ".vhdl"} and any(p in {"sim", "tb", "testbench"} for p in path.parts):
        return "sim"
    return "other"


# --------------------------- Vivado helpers ----------------------------------

def tcl_quote(p: Path) -> str:
    return "{" + str(p) + "}"


def run_vivado_tcl(tcl: str, *, settings: Optional[Path], vivado: str, quiet: bool) -> int:
    """Write Tcl to a temp file and invoke Vivado batch."""
    with tempfile.NamedTemporaryFile("w", suffix=".tcl", delete=False) as tf:
        tf.write(tcl)
        tcl_path = Path(tf.name)

    cmd = f'{shlex.quote(vivado)} -mode batch -nolog -nojournal -notrace -source {shlex.quote(str(tcl_path))}'
    try:
        if settings:
            full = f'source {shlex.quote(str(settings))} && {cmd}'
            proc = subprocess.run(["bash", "-lc", full], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        else:
            proc = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        if not quiet:
            click.echo(proc.stdout, nl=True)
        return proc.returncode
    finally:
        try:
            tcl_path.unlink(missing_ok=True)
        except Exception:
            pass


def make_prelude_open_project(xpr: Path) -> str:
    return f"""
set proj {tcl_quote(xpr.resolve())}
if {{![file exists $proj]}} {{
  puts "ERROR: Project not found: $proj"
  exit 2
}}
open_project $proj
set_msg_config -severity INFO -suppress
"""


# --------------------------- project discovery --------------------------------

def find_xpr(hint: Optional[Path], proj_dir: Optional[Path] = None) -> Path:
    """
    Prefer .xpr under project_files/ (or user --proj-dir), unless an explicit .xpr path is given.
    """
    if hint and hint.is_file() and hint.suffix.lower() == ".xpr":
        return hint.resolve()

    base = Path(".") if hint is None else (hint if hint.is_dir() else hint.parent)
    proj_root = (proj_dir or Path(PROJECT_DIR_DEFAULT))
    search_dir = (base / proj_root) if (proj_root != Path(".")) else base

    xprs = sorted(search_dir.glob("*.xpr"), key=lambda p: p.stat().st_mtime, reverse=True)
    if not xprs:
        raise click.UsageError(f"No .xpr found in {search_dir.resolve()}. "
                               f"Run 'vproj import-tcl --proj-dir {proj_root}' first.")
    if len(xprs) > 1:
        click.echo(f"Found multiple .xpr files; using newest: {xprs[0].name}", err=True)
    return xprs[0].resolve()


# --------------------------- CLI root ----------------------------------------

@click.group(context_settings=dict(help_option_names=["-h", "--help"]))
@click.option("--proj", "proj_hint", type=click.Path(path_type=Path), required=False,
              help="Path to .xpr OR a directory to search. If omitted, search current dir.")
@click.option("--vivado", default="vivado", show_default=True,
              help="Vivado executable.")
@click.option("--settings", type=click.Path(path_type=Path, exists=True),
              help="Optional settings64.sh to source before invoking Vivado.")
@click.option("-q", "--quiet", is_flag=True, help="Suppress Vivado stdout.")
@click.option("--proj-dir", type=click.Path(path_type=Path), default=PROJECT_DIR_DEFAULT, show_default=True,
              help="Directory where the Vivado project (.xpr) lives (created on import).")
@click.pass_context
def cli(ctx, proj_hint: Optional[Path], vivado: str, settings: Optional[Path], proj_dir: Optional[Path], quiet: bool):
    """Manage Vivado .xpr projects (add/remove/list/export-tcl/import-tcl) without the GUI."""
    ctx.ensure_object(dict)
    ctx.obj.update(vivado=vivado, settings=settings, quiet=quiet, proj_hint=proj_hint, proj_dir=proj_dir)


# --------------------------- list/add/remove ----------------------------------

@cli.command("list")
@click.pass_context
def list_cmd(ctx):
    """List files in sources_1, constrs_1, and sim_1 (fileset|path|type)."""
    xpr = xpr = find_xpr(ctx.obj["proj_hint"], ctx.obj["proj_dir"])
    tcl = make_prelude_open_project(xpr) + r"""
foreach fs [list sources_1 constrs_1 sim_1] {
  set fsobj [get_filesets -quiet $fs]
  if {[llength $fsobj] == 0} { continue }
  foreach f [get_files -of_objects $fsobj] {
    set p [get_property NAME $f]
    set t [get_property FILE_TYPE $f]
    puts "$fs|$p|$t"
  }
}
close_project
"""
    raise SystemExit(run_vivado_tcl(tcl, settings=ctx.obj["settings"], vivado=ctx.obj["vivado"], quiet=ctx.obj["quiet"]))


@cli.command("add")
@click.argument("files", type=click.Path(path_type=Path, exists=True), nargs=-1, required=True)
@click.option("--type", "forced_kind",
              type=click.Choice(VALID_KINDS, case_sensitive=False),
              help="Force file kind (otherwise auto-detect by extension).")
@click.pass_context
def add_cmd(ctx, files: Tuple[Path, ...], forced_kind: Optional[str]):
    """Add one or more files to the project (auto-detect type by extension)."""
    xpr = xpr = find_xpr(ctx.obj["proj_hint"], ctx.obj["proj_dir"])
    lines: List[str] = [make_prelude_open_project(xpr)]
    for p in files:
        kind = forced_kind.lower() if forced_kind else detect_kind(p)
        fs = KIND_FILESET[kind]
        lines.append(f'puts "ADD {fs} {p.name}"')
        lines.append(f"add_files -fileset {fs} {tcl_quote(p.resolve())}")
        if kind == "xdc":
            lines.append(f"set f [get_files {tcl_quote(p.resolve())}]")
            lines.append("if {[llength $f] > 0} {"
                         "set_property USED_IN_SYNTHESIS true $f; "
                         "set_property USED_IN_IMPLEMENTATION true $f; }")
    lines += ["close_project"]
    tcl = "\n".join(lines) + "\n"
    code = run_vivado_tcl(tcl, settings=ctx.obj["settings"], vivado=ctx.obj["vivado"], quiet=ctx.obj["quiet"])
    if code == 0 and not ctx.obj["quiet"]:
        click.echo("ADD: done.")
    raise SystemExit(code)


@cli.command("remove")
@click.argument("files", type=click.Path(path_type=Path), nargs=-1, required=True)
@click.pass_context
def remove_cmd(ctx, files: Tuple[Path, ...]):
    """Remove one or more files from the project (from any fileset)."""
    xpr = xpr = find_xpr(ctx.obj["proj_hint"], ctx.obj["proj_dir"])
    lines = [make_prelude_open_project(xpr)]
    for p in files:
        rp = tcl_quote(Path(p).resolve())
        lines.append(f'puts "REMOVE {Path(p).name}"')
        lines.append(f"set objs [get_files -quiet {rp}]")
        lines.append("if {[llength $objs] > 0} { remove_files $objs } else {"
                     f'puts "WARN: File not in project: {Path(p)}"; }}')
    lines += ["close_project"]
    tcl = "\n".join(lines) + "\n"
    code = run_vivado_tcl(tcl, settings=ctx.obj["settings"], vivado=ctx.obj["vivado"], quiet=ctx.obj["quiet"])
    if code == 0 and not ctx.obj["quiet"]:
        click.echo("REMOVE: done.")
    raise SystemExit(code)


# --------------------------- export/import project.tcl ------------------------

@cli.command("export-tcl")
@click.option("--out", "out_tcl", type=click.Path(path_type=Path), default=Path("project.tcl"), show_default=True)
@click.option("--rel-to", "rel_to", type=click.Path(path_type=Path), default=Path("."), show_default=True)
@click.option("--no-copy-sources", is_flag=True)
@click.option("--keep-dcp", is_flag=True)
@click.pass_context
def export_tcl_cmd(ctx, out_tcl: Path, rel_to: Path, no_copy_sources: bool, keep_dcp: bool):
    import re
    xpr = find_xpr(ctx.obj["proj_hint"], ctx.obj["proj_dir"])

    flags = ["-force", "-all_properties", "-paths_relative_to", str(rel_to.resolve())]
    if no_copy_sources: flags += ["-no_copy_sources"]
    flags_str = " ".join(flags)

    tcl = make_prelude_open_project(xpr)
    if not keep_dcp:
        tcl += r"""
# clear incremental checkpoints on runs and steps
foreach r [get_runs] {
  foreach p {
    incremental_checkpoint
    STEPS.SYNTH_DESIGN.ARGS.INCREMENTAL_CHECKPOINT
    STEPS.OPT_DESIGN.ARGS.INCREMENTAL_CHECKPOINT
    STEPS.PLACE_DESIGN.ARGS.INCREMENTAL_CHECKPOINT
    STEPS.PHYS_OPT_DESIGN.ARGS.INCREMENTAL_CHECKPOINT
    STEPS.ROUTE_DESIGN.ARGS.INCREMENTAL_CHECKPOINT
  } {
    catch { reset_property $p $r }
    catch { set_property $p {} $r }
  }
}
foreach fs [get_filesets *] {
  catch { reset_property incremental_checkpoint $fs }
  catch { set_property incremental_checkpoint {} $fs }
}
# drop imported artifacts (memory only)
set _rm {}
foreach f [get_files -all] {
  if {[string match *.dcp $f] || [string match *.edif $f] || [string match *imports/* $f]} {
    lappend _rm $f
  }
}
if {[llength $_rm]} { remove_files -quiet $_rm }
"""
    tcl += f"""
file mkdir [file dirname {tcl_quote(out_tcl.resolve())}]
write_project_tcl {flags_str} {tcl_quote(out_tcl.resolve())}
close_project
"""
    code = run_vivado_tcl(tcl, settings=ctx.obj["settings"], vivado=ctx.obj["vivado"], quiet=ctx.obj["quiet"])

    if code == 0 and out_tcl.exists():
        txt = out_tcl.read_text()

        # 1) Make the original-project root portable (this script uses orig_proj_dir, not origin_dir)
        #    Example line in your file:
        #    set orig_proj_dir "[file normalize "$origin_dir/"]"
        txt = re.sub(
            r'(?m)^set\s+orig_proj_dir\s+.*$',
            'set orig_proj_dir "[file normalize [pwd]/]"',
            txt
        )

        # 2) (Optional) if some Vivado versions still emit set origin_dir ... keep this too
        txt = re.sub(
            r'(?m)^set\s+origin_dir\s+.*$',
            'set origin_dir [file normalize [pwd]]',
            txt
        )

        # 3) Nuke any incremental checkpoint or imports references (belt & suspenders)
        txt = re.sub(r'(?mi)^.*incremental_checkpoint.*$', '', txt)
        txt = re.sub(r'(?m)^.*utils_1/imports/.*$',        '', txt)

        # 4) Clean up extra blank lines
        txt = re.sub(r'\n{3,}', '\n\n', txt)

        out_tcl.write_text(txt)

    if code == 0 and not ctx.obj["quiet"]:
        click.echo(f"Wrote {out_tcl} (from {xpr.parent.name}/).")
    raise SystemExit(code)


@cli.command("import-tcl")
@click.argument("project_tcl", type=click.Path(path_type=Path, exists=True))
@click.option("--workdir", type=click.Path(path_type=Path), help="cd before sourcing TCL.")
@click.option("--force", is_flag=True, help="Overwrite existing project.")
@click.option("--wipe", is_flag=True, help="Delete the project_dir before import.")
@click.pass_context
def import_tcl_cmd(ctx, project_tcl: Path, workdir: Optional[Path], force: bool, wipe: bool):
    import re, tempfile, shutil
    proj_dir = (ctx.obj["proj_dir"]).resolve()
    proj_dir.mkdir(parents=True, exist_ok=True)

    if wipe and proj_dir.exists():
        shutil.rmtree(proj_dir, ignore_errors=True)
        proj_dir.mkdir(parents=True, exist_ok=True)

    src = Path(project_tcl).read_text()

    
    # 1) Re-point the project directory argument in 'create_project'
    #    Match: <spaces>create_project <NAME> <DIR> <rest...>
    #    Keep NAME & rest, replace only <DIR>.
    proj_dir_abs = (ctx.obj["proj_dir"]).resolve()
    create_proj_re = re.compile(r'(?m)^(?P<prefix>\s*create_project\s+\S+)\s+(?P<dir>\S+)(?P<rest>.*)$')
    def _replace_proj_dir(m):
        return f'{m.group("prefix")} ' + "{" + str(proj_dir_abs) + "}" + m.group("rest")
    src, n = create_proj_re.subn(_replace_proj_dir, src, count=1)

    # Make original-project root portable (this file uses orig_proj_dir)
    src = re.sub(
        r'(?m)^set\\s+orig_proj_dir\\s+.*$',
        'set orig_proj_dir "[file normalize [pwd]/]"',
        src
    )

    # (Optional) Some Vivado scripts also have set origin_dir; normalize it too
    src = re.sub(
        r'(?m)^set\\s+origin_dir\\s+.*$',
        'set origin_dir [file normalize [pwd]]',
        src
    )

    # Inject -force if requested (keeps your existing code)
    if force:
        def add_force(m):
            line = m.group(0)
            return line if "-force" in line else line.replace("create_project", "create_project -force", 1)
        src = re.sub(r'(?m)^\\s*create_project\\b[^\\n]*', add_force, src, count=1)

    with tempfile.NamedTemporaryFile("w", suffix=".tcl", delete=False) as tf:
        tf.write(src)
        patched = Path(tf.name)

    pre = ""
    if workdir:
        pre = f"cd {tcl_quote(Path(workdir).resolve())}\n"
    tcl = pre + f"source {tcl_quote(patched)}\n"
    code = run_vivado_tcl(tcl, settings=ctx.obj["settings"], vivado=ctx.obj["vivado"], quiet=ctx.obj["quiet"])
    try:
        patched.unlink(missing_ok=True)
    finally:
        raise SystemExit(code)

# --------------------------- entry -------------------------------------------

def main():
    cli(obj={})

if __name__ == "__main__":
    main()